## Crypto

### DHRSA

首先要得到$r$和$g$。分析可得，若$r$已知，且存在$GCD(c1,c2)=1$，那么我们就可以计算出$g$。因此最开始先要得到$r$。

构造矩阵如下图所示：
$$
B = \begin{bmatrix}
{1}&{0}&{\cdots}&{0}&{c_1<<512}\\
{0}&{1}&{\cdots}&{0}&{c_2<<512}\\
{\vdots}&{\vdots}&{\ddots}&{\vdots}&{\vdots}\\
{0}&{0}&{\cdots}&{1}&{c_n<<512}\\
\end{bmatrix}
$$
用LLL算法求$L(B)$上的短向量。对于某一个短向量$V$而言，几乎可以判定$c_1*v_1+c_2*v_2+...+c_n*v_n=0$。由于缺少$r$，无法计算逆元，我们不妨按$v_i$的符号将上式分至等号两端，也即$\Sigma_{i,v_i\geq0} c_i*v_i = \Sigma_{j,v_j<0} c_j*(-v_j)$。因此有$\Pi_{i,v_i\geq0} C_i^{v_i} - \Pi_{j,v_j<0} C_j^{(-v_j)}=0 \ mod\ r$，也即左式为$r$的倍数。因此，只需对多个短向量求$\Pi_{i,v_i\geq0} C_i^{v_i} - \Pi_{j,v_j<0} C_j^{(-v_j)}$，再求GCD即可。第一部分代码如下：

```python
C_raw = [(... , ...) , ... , (... , ...)]
from sage.all import *
c = [x[0] for x in C_raw]
C = [x[1] for x in C_raw]

# print(c[0],C[0])

n = len(C)
L = matrix(n,n + 1)
# print(L)

for row in range(n):
    L[row, row] = 1
    L[row, -1 ] = c[row]<<512

vec = L.LLL()
res = []
for _ in range(5):
    v = vec[_][:-1]
    l = 1
    r = 1
    for i in range(n):
        if v[i] < 0:
            r *= C[i]**(-v[i])
        else:
            l *= C[i]**v[i]
    res.append(r-l)
r = reduce(GCD, res)
print(r)
```

得到$r$如下：

```
1260952453605461833945819484364997441835839576140060911820213996495636322169240963248030152138676573889880012287524366850719749859418561196005733181618580850396854191283147767495687891077346619441625464026405642024317639147420671848621389326408860875135630940950698490000835089563948536138987132836412047645002521895663157449547945395948083588999995405343419270767313930908610572710500644133660486677702625226548970429436492314172669392164245326819168733338721550564479216563551561400520145072974878753598980633667053022306504239345253351744276583287837522349537449741211276466001882044249148981527886202133093666112517343139539357240583904623502253689232037589166318100133861451950624083868313417107063719867743038408146744948593286674686730715705201873743761306024670441378134334773709664029387332029254130326635601376789578842322733540726762837781876274687032388754410170299853877894677999552255251431703803686869241671374082588316306972599011402012045950017801520460869318920183932061008148462359027765382130356407806013445473694312842694597970025228541959086008184949943977898743473001519948862101834063819543866500565752874943111555019171591859024062254933599440429473105210665851861177403161153038276664145087389832318454504045042197973575369776796883803522365972745049847186210260325129254349130362431891183559919942966217128268048354471832213101690228386960180102050138725960098390634528323986798859224683850998182657043931255197925376000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

factordb直接分解，可得真正$r$为：

```python
10667924450645948100608927157603781268991945924055943816082403476371801785989561454936076097627912279097114498936308342036099904242687703932444772733243819
```

可顺势算出$g$。第二部分代码如下：

```python
b = (8272821018041191335817314516024870641634584838709754134295649414123178842937800314505950304166260273130361466329869880024580711311122266329063823157928578, 6731047210123888962354325580924677204725121336252367061814596228770531939085170702108835833376855510135160514592212524395740859425722612967050674897558554)
c = (9224196545381524434689958500941052085722509493323098161219607220849299786695264643219965900283680542442505315754998495711744726427299710433730839117822341, 8618477079542034439812499299348172601780082410118486479357089433765711733400709574657418048464225715724091467457454996920521245517408697962287328781660172)


r = 10667924450645948100608927157603781268991945924055943816082403476371801785989561454936076097627912279097114498936308342036099904242687703932444772733243819

def Exgcd(a, b):
    if b == 0:
        return a, 1, 0
    d, x, y = Exgcd(b, a % b)
    return d, y, x - (a // b) * y

def get_g(C1,C2):
    d,x,y = Exgcd(C1[0],C2[0])
    print(d)
    assert d == C1[0]*x+C2[0]*y
    print(pow(C1[1],x,r)*pow(C2[1],y,r))
    return pow(C1[1],x,r)*pow(C2[1],y,r)

G = get_g(b,c)
assert pow(G,c[0],r) == c[1]
```

得到$g$后，直接用sage内置的离散对数求解$x$并爆破$t1、t2$，即可得到余下所有值。代码如下：

```python
from sage.all import *
r = 10667924450645948100608927157603781268991945924055943816082403476371801785989561454936076097627912279097114498936308342036099904242687703932444772733243819
G = 2741960939914083696293913369135536579810046510267309980231181339481009794397335214239605015461654630713132354908000701730973776273166372495010337536841641716286586174284120152774393736250052401247356168349434990008958820287883961646744738404027169593483554083332780948552091246695801600599121850376426478706

X = 197551296081022143608034360606381334253374533627365455002683616928330857539205836504075700389569213696043700490195977045586318090211726350917451410932216
W = 10625560347436147537644301075885059900758953251551866239435327407977591190018531918316486861730777808988185029637608372445416280896280058313924537678128258

# x = discrete_log(X,mod(G,r))
x = 10661668070998584360419309727765572397096868781636098095295487404295848193280503932533547717105939587559768619286290065762620186259047850096911244235337628
assert pow(G,x,r) == X
print(x)

n = 66022752859576751705544115674843820574619778139841743306742674741819040147745776264697779394213058328572691946505564202779552568613562176486470653760142864852745249430164256770469301179840812051842363261404790355057115296671805975126795017665392798621718740402876024901551851638786170466127104615340863081593
e = 65537
c = 61040814411609979711931510878805548760848686739454567580358315369154260598969544907138563610735920809370306294050956464828615417082277087799410050319871691154003766481799397897519555113273982347768485719165972634089532894585256662433949694618032747408071953491187718726218120284389638124624152241321006634774
for t1 in range(2):
    for t2 in range(2):
        C = (n*pow(W,t2-t1,r))%r
        p = (C * W**t1 * pow(C, x, r) % r)
        q = (pow(W, -t2, r) * pow(C, -x, r) % r)
        if(q*p==n):
            print(p,q)
            phi = (p-1)*(q-1)
            d = inverse(e,phi)
            m = pow(c,d,n)
            print(long_to_bytes(m))
```

